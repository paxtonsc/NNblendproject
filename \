import torch
from torch import nn
from torch.autograd import Variable
import torch.nn.functional as F

import numpy as np
import os


def load_data():
	x_file = os.path.join('output', 'gal_sim_params.txt')
	y_file = os.path.join('output', 'accurate.txt')
	
	x = np.loadtxt(x_file)
	x = np.reshape(x, (int(x.shape[0]/2), x.shape[1]*2))
	y = np.loadtxt(y_file)
	y = y.reshape(len(y), 1)

	x_train = x[0:900,:]
	x_valid = x[900:,:]
	y_train = y[0:900,:]
	y_valid = y[900:1000,:]

	return (x_train, y_train, x_valid, y_valid)


class Neural_Network(nn.Module):
	def __init__(self):
		super(Neural_Network, self).__init__()
		self.inputSize = 18
		self.hiddenSize = 36
		self.outputSize = 1

		# weights
		self.W1 = torch.randn(self.inputSize, self.hiddenSize)
		self.W2 = torch.randn(self.hiddenSize, self.outputSize)
	
	def forward(self, t):
		self.z = torch.matmul(X, self.W1)
		self.z2 = self.sigmoid(self.z)
		self.z3 = torch.matmul(self.z2, self.W2)
		o = self.sigmoid(self.z3)
		return o
	
	def sigmoid(self, s):
		return 1/(1 + torch.exp(-s))


	def sigmoidPrime(self, s):
		return s * (1 -s)

	def backward(self, X, y, o):
		self.o_error = y - o
		self.o_delta = self.o_error * self.sigmoidPrime(o)

		self.z2_error = torch.matmul(self.o_delta, torch.t(self.W2))
		self.z2_delta = self.z2_error * self.sigmoidPrime(self.z2)

		self.W1, self.W2 = self.W1, self.W2

		self.W1 += .001 * torch.matmul(torch.t(X), self.z2_delta)
		self.W2 += 0.001 * torch.matmul(torch.t(self.z2), self.o_delta)

	def train(self, X, y):
		o = self.forward(X)
		self.backward(X,y,o)
	
	def saveWeights(self, model):
		torch.save(model, 'NN')

	def predict(self, X):
		return forward(X).round()
	

X, y, X_valid, y_valid = load_data()
X = torch.from_numpy(X).float()
y = torch.from_numpy(y).float()
y_valid = torch.from_numpy(y_valid).float()
xPredicted = torch.from_numpy(X_valid).float()

NN = Neural_Network()

for i in range(5000):
	if (i%10 == 0):
		print('#' + str(i) + ' Loss: ' + str(torch.mean((y - NN(X))**2).detach().item()))
	NN.train(X, y)

NN.saveWeights(NN)
NN.predict(xPredicted)
y_pred = NN.forward(xPredicted)
print(y_valid[0:15,:])
print(y_pred[0:15,:])
print('Accuracy:')
print(1 - torch.sum(y_pred.round() - y_valid)/100)
print("There are ", torch.sum(y_valid), " ones ")
